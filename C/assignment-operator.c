// ------------------------------
// Оператор присваивания. Запись значения в переменную на Си
// ------------------------------

// = это оператор присваивания

int z;	// объявляем переменную целого типа с именем z
z = 5;	// сохраняем в переменную число 5

double pi = 3.1415926; // создаём переменную и сразу присваиваем ей значение

// В примере выше показаны два способа присвоить значение переменной. В первом случае мы сначала создаём переменную, а потом записываем в неё значение, а во втором — сразу создаём переменную и присваиваем ей значение. 
// В умных книжках второй вариант записи ещё называют инициализация переменной. Так что, если где-то встретите выражение навроде проинициализируем вещественную переменную pi значением 3.1415926, то не пугайтесь.

// в некоторых языках программирования, после того как вы создали переменную, в ней сразу же хранится значение нуль. В языке Си это не так. Пока переменной не присвоено какое-нибудь значение, в ней будет храниться "мусор". 
// Как этот мусор выглядит, мы посмотрим на следующем уроке.

// справа от знака равенства не обязательно должно быть записано какое-то конкретное число, там может быть записано, например, арифметическое выражение или имя другой переменной, объявленной ранее.

int n;
n = 1 + 2;	// В переменную n записываем значение 3

int n = 10;	// Создаём переменную и записываем в неё 10
n = 5;	// Теперь в переменной записано значение 5, значение 10 удалено.

// В выражении справа от знака равенства могут использоваться другие переменные, которые объявлены ранее. Вместо них в выражение подставляются значения, которые в них хранятся в данный момент.

int n = 10, x = 0; 	// можно инициализировать сразу несколько переменных
n = 5; 	// теперь n равно 5
x = n - 3; // x будет равно 2 (5-3)

// При вычислении выражения n - 3, n равняется 5. Это потому, что исходное значение 10, заданное при инициализации, мы в программе изменяли. А при вычислениях используется текущее значение переменной.

// В выражении справа от знака равенства может быть использована сама переменная.

int n = 10;
n = n + 5; 	// n будет равно 15 (10 + 5)

// Кажется, что это какой-то порочный круг, но на самом деле проблем здесь не возникнет. Т.к. сначала вычисляется значение выражения справа, и только потом происходит присваивание. 
// По аналогии с предыдущим примером при вычислении значения справа от знака равенства вместо переменной n будет подставлено её текущее значение, т.е. 10. Потом будет произведено сложение и присваивание.

int x = 5, y = 0, z;
y = x + z; 	// что будет записано в переменной y?

// Если вы подумали что 5, то вы ошиблись. Неизвестно, что в неё будет записано т.к. неизвестно, что было записано в переменную z. Ещё раз напоминаю: если переменной не присвоено никакое значение, в ней хранится не нуль, а неизвестно что.

// Выражение справа от знака равенства может быть достаточно сложным, оно не обязательно будет состоять из одного действия.

int a = 2, b = 9, c = 4, D;

D = b*b - 4*a*c; 	// D будет равно 49 (9*9 - 4*2*4)

// Почему именно так? У каждого арифметического действия есть свой "вес" , или, иначе говоря, приоритет. Например, вы уже наверняка знаете, что сначала в выражениях выполняется деление и умножение, а только потом вычитание и сложение. В программировании всё так же. 
// Подробнее о приоритетах различных операций ещё будем говорить в следующих уроках.

// Теперь ещё один важный момент, который надо понимать. Когда я рассказывал о типах данных, я говорил, что в переменной можно хранить значения только того же типа, что и тип переменной. Например, в переменную целого типа нельзя положить вещественное число. Этот принцип применяется и с выражениями. 
// Чтобы программа работала корректно, необходимо, чтобы тип выражения или переменной справа от знака присваивания совпадал с типом переменной.

int n, a = 2;
double x, pi = 3.14;
char s = 'k'; 	// сохраняем в переменную s символ k. 
                // Сам символ нужно написать в одинарных кавычках.

s = pi; // неправильно. В коробку для символов пытаемся положить вещественное число

n = a*pi; // неправильно. В коробку для целых чисел пытаемся положить 6.28 (2*3.14)

a = x; // неправильно. В целочисленную переменную пытаемся сохранить вещественное число

x = 2 + a;	// ДОПУСТИМО!!! x будет равно 4.0